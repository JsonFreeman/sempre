(rule $ROOT (if $SENTENCE (, optional) (then optional) $SENTENCE .) (lambda x (lambda y (call + (var x) (string " & ~") (var y)))))
(rule $ROOT ($SENTENCE .) (lambda x (call + (string "~") (var x))))
(rule $SENTENCE ($SENTENCE and $SENTENCE) (lambda x (lambda y (call + (var x) (string " & ") (var y)))))
(rule $SENTENCE ($PHRASE $SENTENCE $PHRASE) (lambda x (lambda y (lambda z (var y)))))


# remove
(rule $PADDING (be) (ConstantFn (string "")))
(rule $PADDING (the) (ConstantFn (string "")))
(rule $PADDING (a) (ConstantFn (string "")))  
(rule $PADDING ($PADDING $PADDING) (lambda x (lambda y (var x))))


# variable labels
(rule $FORM (form) (ConstantFn (string "")))
(rule $FORM (line) (ConstantFn (string "")))


# modals
(rule $MODAL ($PHRASE) (IdentityFn))


# modal negations
(rule $NEGATION (not) (ConstantFn (string "~")))
(rule $NEGATION (cannot) (ConstantFn (string "")))

(rule $NEGMODAL ($MODAL) (ConstantFn (string "")))
(rule $NEGMODAL ($MODAL $NEGATION) (ConstantFn (string "~")))

# comparisons
(rule $SENTENCE ($FIELD $NEGMODAL $REL $FIELD) (lambda x (lambda y (lambda r (lambda z (call + (var y) (var r) (string "(") (var x) (string ",") (var z) (string ")")))))))

(rule $REL ($PHRASE greater $PHRASE) (lambda x (lambda z (string "greater_than"))))
(rule $REL ($PHRASE greater than or equal $PHRASE) (lambda x (lambda z (string "greater_than_equal_to"))))
(rule $REL ($PHRASE less $PHRASE) (lambda x (lambda z (string "less_than"))))
(rule $REL ($PHRASE less than or equal $PHRASE) (lambda x (lambda z (string "less_than_equal_to"))))
(rule $REL ($PHRASE equal $PHRASE) (lambda x (lambda z (string "same"))))

# field value
(rule $SENTENCE ($FIELD $MODAL non zero value) (lambda x (lambda y (call + (string "non_zero(") (var x) (string ")")))))
(rule $SENTENCE ($FIELD has the value (` optional) $TOKEN (' optional)) (lambda x (lambda y (call + (string "value(") (var x) (string ",") (var y) (string ")")))))


# implied field value
(rule $SENTENCE ($FORM $PHRASE \( element ` $TOKEN ' $MODAL value $TOKEN \) ) (lambda v (lambda w (lambda x (lambda y (lambda z (call + (string "value(") (var x) (string ",") (var z) (string ")"))))))))
(rule $SENTENCE ($FORM $PHRASE \( element ` $TOKEN ' $MODAL $NEGATION value $TOKEN \) ) (lambda u (lambda v (lambda w (lambda x (lambda y (lambda z (call + (string "~value(") (var v) (string ",") (var z) (string ")")))))))))
(rule $SENTENCE ($FORM $PHRASE \( element ` $TOKEN ' $MODAL equal to $TOKEN \) ) (lambda v (lambda w (lambda x (lambda y (lambda z (call + (string "value(") (var x) (string ",") (var z) (string ")"))))))))
(rule $SENTENCE ($FORM $PHRASE \( element ` $TOKEN ' $MODAL $NEGATION equal to $TOKEN \) ) (lambda u (lambda v (lambda w (lambda x (lambda y (lambda z (call + (string "~value(") (var v) (string ",") (var z) (string ")")))))))))


# field value existence
(rule $SENTENCE ($FIELD has a value) (lambda x (call + (string "has_value(") (var x) (string ")"))))
(rule $SENTENCE ($FIELD $MODAL checked) (lambda x (lambda y (call + (string "has_value(") (var x) (string ")")))))
(rule $SENTENCE ($FIELD $MODAL $NEGATION checked) (lambda x (lambda y (lambda z (call + (string "~has_value(") (var x) (string ")"))))))
(rule $SENTENCE ($FIELD $MODAL value) (lambda x (lambda y (call + (string "has_value(") (var x) (string ")")))))
(rule $SENTENCE ($FIELD must be equal to zero if an amount is entered) (lambda x (call + (string "~non_zero(") (var x) (string ")"))))
(rule $SENTENCE ($FIELD must be equal to zero or not be present) (lambda x (call + (string "~non_zero(") (var x) (string ")"))))


# Tax-specific field value
(rule $SENTENCE ($FIELD in the return header is an itin) (lambda x (call + (string "iTin(") (var x) (string ")"))))
(rule $SENTENCE (schedule $TOKEN \( $TOKEN $TOKEN \) must be attached) (lambda x (lambda y (lambda z (call + (string "has_value(schedule") (var x) (string ")"))))))
(rule $SENTENCE (schedule $TOKEN must not be attached) (lambda x (call + (string "~has_value(schedule") (var x) (string ")"))))
(rule $SENTENCE (schedule $TOKEN \( $TOKEN $TOKEN \) is present in the return) (lambda x (lambda y (lambda z (call + (string "has_value(schedule") (var x) (string ")"))))))


# extract field name
(rule $FIELD ($FORM $TOKEN , $FORM $TOKEN (checkbox optional) ` $TOKEN ') (lambda v (lambda w (lambda x (lambda y (lambda z (var z)))))))
(rule $FIELD (schedule $TOKEN $TOKEN $TOKEN , line $TOKEN ` $TOKEN ') (lambda v (lambda w (lambda x (lambda y (lambda z (var z)))))))
(rule $FIELD ($FORM $TOKEN (checkbox optional) ` $TOKEN ') (lambda x (lambda y (lambda z (var z)))))
(rule $FIELD (` $TOKEN ') (lambda x (var x)))

# TODO
# non-if-then
# schedule X variables
# form X variables
# normalize to Xpresent 
