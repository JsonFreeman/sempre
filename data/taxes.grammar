# Basic construct of the utterance
(rule $ROOT (if $SENTENCE (, optional) (then optional) (, optional) $SENTENCE .) (lambda x (lambda y (call + (var x) (string " & ~") (var y)))))
(rule $ROOT ($SENTENCE .) (lambda x (call + (string "~") (var x))))
(rule $SENTENCE (\( $SENTENCE \)) (lambda x (var x)))
(rule $SENTENCE ([ $SENTENCE ]) (lambda x (var x)))
(rule $SENTENCE ($SENTENCE ,) (lambda x (var x)))
(rule $SENTENCELIST ($SENTENCE) (IdentityFn))
(rule $SENTENCE ($SENTENCE $SENTENCELIST) (lambda x (lambda y (var x))))
(rule $SENTENCE ($SENTENCE $SENTENCELIST) (lambda x (lambda y (var y))))
(rule $SENTENCE ($SENTENCE and $SENTENCELIST) (lambda x (lambda y (call + (var x) (string " & ") (var y)))))
(rule $SENTENCE ($SENTENCE or $SENTENCELIST) (lambda x (lambda y (call + (var x) (string " | ") (var y)))))
(rule $SENTENCE ($SENTENCE unless $SENTENCELIST) (lambda x (lambda y (call + (var x) (string " | ") (var y)))))
(rule $SENTENCE ($SENTENCE if $SENTENCELIST) (lambda x (lambda y (call + (var x) (string " | ~") (var y)))))

# Field names
# TODO: account for parenthesized field names
(rule $FIELD (form $TOKEN) (lambda x (call + (string "form") (var x))))
(rule $FIELD (form $TOKEN $TOKEN) (lambda x (lambda y (call + (string "form") (var x) (var y)))))
(rule $FIELD (line $TOKEN) (lambda x (call + (string "line") (var x))))
(rule $FIELD (part $TOKEN) (lambda x (call + (string "part") (var x))))
(rule $FIELD (section $TOKEN) (lambda x (call + (string "section") (var x))))
(rule $FIELD (column \( $TOKEN \)) (lambda x (call + (string "column") (var x))))
(rule $FIELD (line $TOKEN \( $TOKEN \)) (lambda x (lambda y (call + (string "line") (var x) (var y)))))
(rule $FIELD (\( $FIELD \)) (lambda x (var x)))
(rule $FIELD ($FIELD ,) (lambda x (var x)))
(rule $FIELD (schedule $TOKEN (, optional)) (lambda x (call + (string "schedule") (var x))))
(rule $FIELD (`` $PHRASE '') (ConstantFn (string "")))
(rule $FIELD (checkbox $TOKEN) (lambda x (var x)))
(rule $FIELD (checkbox $TOKEN $TOKEN) (lambda x (lambda y (call + (var x) (var y)))))
(rule $FIELD (checkbox $TOKEN $TOKEN $TOKEN) (lambda x (lambda y (lambda z (call + (var x) (var y) (var z))))))
(rule $FIELDNAME (` $TOKEN ') (lambda x (var x)))
(rule $FIELDNAME ([ $TOKEN ]) (lambda x (var x)))
(rule $FIELDNAME ($FIELDNAME ,) (lambda x (var x)))
(rule $FIELDNAME (element $FIELDNAME) (lambda x (var x)))
(rule $FIELDNAME ($FIELDNAME checkbox) (lambda x (var x)))
(rule $FIELDNAME (checkbox $FIELDNAME) (lambda x (var x)))
(rule $FIELDNAME (checkbox $FIELD) (lambda x (var x)))
(rule $FIELDNAME ($FIELD $FIELDNAME) (lambda x (lambda y (var y))))

# This is cheating
(rule $FIELD (form $TOKEN or $TOKEN) (lambda x (lambda y (call + (string "form") (var x)))))
(rule $FIELD (form $TOKEN or form $TOKEN) (lambda x (lambda y (call + (string "form") (var x)))))
(rule $FIELD (schedule $TOKEN (, optional)) (lambda x (call + (string "formschedule") (var x))))
(rule $FIELDNAME (($TOKEN optional) ($TOKEN optional) ($TOKEN optional) ($TOKEN optional) ($TOKEN optional) [ $TOKEN ]) (lambda x (var x)))
(rule $ENT ($FIELD) (lambda x (var x)))
(rule $ENT ($FIELD $ENT) (lambda x (lambda y (var y))))

(rule $ENT ($FIELDNAME) (lambda x (var x)))
(rule $ENT ($TOKEN) (lambda x (var x)))
(rule $ENT ($TOKEN $TOKEN) (lambda x (lambda y (call + (var x) (var y)))))
(rule $ENT (zero) (ConstantFn (string "0")))
(rule $ENT ($DET $ENT) (lambda x (lambda y (var y))))
(rule $ENT (each $ENT) (lambda x (var x)))
(rule $ENT (any $ENT) (lambda x (var x)))

# LIFTED_ENT takes the predicate as the argument
(rule $LIFTED_ENT (($PRE_CONJ optional) $ENT $CONJ $ENT) (lambda x (lambda c (lambda y (lambda f (call + (string "(")
																				(call + (var f) (string "(") (var x) (string ")"))
																				(var c)
																				(call + (var f) (string "(") (var y) (string ")"))
																				(string ")")))))))
(rule $DOUBLY_LIFTED_ENT (($PRE_CONJ optional) $ENT $CONJ $ENT) (lambda x (lambda c (lambda y (lambda f (call + (string "(")
																					((var f) (var x))
																					(var c)
																					((var f) (var y))
																					(string ")")))))))

# Conjunctions
(rule $CONJ (and) (ConstantFn (string " & ")))
(rule $CONJ (or) (ConstantFn (string " | ")))
(rule $PRE_CONJ (either) (ConstantFn (string "")))
(rule $PRE_CONJ (both) (ConstantFn (string "")))

# (rule $FIELDNAME ($TOKEN $FIELDNAME) (lambda x (lambda y (var y))))
# (rule $FIELDNAME ($FIELDNAME $TOKEN) (lambda x (lambda y (var x))))

# Anaphor
(rule $FIELDNAME (it) (ConstantFn (string "ANAPHOR")))
(rule $FIELDNAME (($DET optional) amount) (ConstantFn (string "ANAPHOR")))

# determiners
(rule $DET (a) (ConstantFn (string "")))
(rule $DET (an) (ConstantFn (string "")))
(rule $DET (the) (ConstantFn (string "")))

# Verbs
(rule $TOBE (be) (ConstantFn (string "")))
(rule $TOBE (is) (ConstantFn (string "")))
(rule $TOBE (is not) (ConstantFn (string "~")))
(rule $TOBE (not be) (ConstantFn (string "~")))
(rule $TOBE (are) (ConstantFn (string "")))
(rule $TOBE (are not) (ConstantFn (string "~")))
(rule $MOD (does) (ConstantFn (string "")))
(rule $MOD (does not) (ConstantFn (string "~")))
(rule $MOD (must) (ConstantFn (string "")))
(rule $MOD (must not) (ConstantFn (string "~")))
(rule $MOD (cannot) (ConstantFn (string "~")))
(rule $TOHAVE (have) (ConstantFn (string "")))
(rule $TOHAVE (has) (ConstantFn (string "")))
(rule $TOBE ($MOD be) (lambda x (var x)))
(rule $TOHAVE ($MOD have) (lambda x (var x)))


# Complements
# has a value, has a (zero/non-zero) value, has the value x
(rule $SENTENCE ($DOUBLY_LIFTED_ENT $NEG $PART_APPLIED_REL) (lambda x (lambda y (lambda z ((var x) ((var z) (var y)))))))
(rule $SENTENCE ($PART_APPLIED_REVERSE_REL $DOUBLY_LIFTED_ENT) (lambda z (lambda x ((var x) (var z)))))
(rule $SENTENCE ($ENT $NEG $PART_APPLIED_REL) (lambda x (lambda y (lambda z (((var z) (var y)) (var x))))))
(rule $SENTENCE (($DET optional) choice of (` optional) $TOKEN (' optional) $TOBE indicated $PREP $ENT) (lambda x (lambda y (lambda z (lambda w (call + (var y) (string "value(") (var w) (string ",") (var x) (string ")")))))))

# unary predicates
(rule $NEG ($TOHAVE) (IdentityFn))
(rule $NEG ($TOBE) (IdentityFn))
(rule $PRED (($DET optional) value) (ConstantFn (string "has_value")))
(rule $PRED (($DET optional) non zero value) (ConstantFn (string "non_zero")))
(rule $PRED (($DET optional) present) (ConstantFn (string "has_value")))
(rule $PRED (($DET optional) attached) (ConstantFn (string "has_value")))
(rule $PRED (($DET optional) checked) (ConstantFn (string "has_value")))
(rule $PRED (($DET optional) entered) (ConstantFn (string "has_value")))


(rule $PART_APPLIED_REL (($DET optional) zero value) (ConstantFn (lambda n (lambda x (call + (var n) (string "value(") (var x) (string ",0)"))))))
(rule $PART_APPLIED_REL (($DET optional) value $VALUE) (lambda v (lambda n (lambda x (call + (var n) (string "value(") (var x) (string ",") (var v) (string ")" ))))))
(rule $PART_APPLIED_REL ($REL $ENT) (lambda r (lambda v (lambda n (lambda x (call + (var n) (var r) (string "(") (var x) (string ",") (var v) (string ")" )))))))
(rule $PART_APPLIED_REVERSE_REL ($ENT $TOBE $REL) (lambda v (lambda n (lambda r (lambda x (call + (var n) (var r) (string "(") (var v) (string ",") (var x) (string ")" )))))))
(rule $PART_APPLIED_REL ($PRED) (lambda p (lambda n (lambda x (call + (var n) (var p) (string "(") (var x) (string ")"))))))

# Conjoined PART_APPLIED_REL (predicates)
(rule $PART_APPLIED_REL (($PRE_CONJ optional) $NEG $PART_APPLIED_REL $CONJ $NEG $PART_APPLIED_REL)
(lambda n1 (lambda p1 (lambda c (lambda n2 (lambda p2 (lambda n (lambda x 
	(call + (var n) (string "(") 
		(((var p1) (var n1)) (var x))
		(var c)
		(((var p2) (var n2)) (var x))
		(string ")"))))))))))

(rule $VALUE ($TOKEN) (IdentityFn))
(rule $VALUE (` $TOKEN ') (IdentityFn))
(rule $VALUE (choice of (` optional) $TOKEN (' optional) indicated) (IdentityFn))
(rule $VALUE ($TOKEN $TOKEN) (lambda x (lambda y (call + (var x) (var y)))))
(rule $VALUE ($TOKEN $TOKEN $TOKEN) (lambda x (lambda y (lambda z (call + (var x) (var y) (var z))))))

# be an ITIN

(rule $SENTENCE ($ENT $TOBE ($DET optional) itin) (lambda x (lambda y (call + (var y) (string "iTin(") (var x) (string ")")))))

# be (REL = greater/less than + equal to) $ENT

(rule $REL (greater than) (ConstantFn (string "greater_than")))
(rule $REL (less than) (ConstantFn (string "less_than")))
(rule $REL (equal to) (ConstantFn (string "same")))
(rule $REL (equals) (ConstantFn (string "same")))
(rule $REL (equal) (ConstantFn (string "same")))
(rule $REL (($DET optional) same as) (ConstantFn (string "same")))
(rule $REL (greater than or equal to) (ConstantFn (string "greater_than_equal_to")))
(rule $REL (less than or equal to) (ConstantFn (string "less_than_equal_to")))

(rule $SENTENCE ($ENT $TOBE $REL $ENT) (lambda x (lambda y (lambda z (lambda w (call + (var y) (var z) (string "(") (var x) (string ",") (var w) (string ")")))))))

(rule $SENTENCE ($ENT $TOBE $REL $NUM) (lambda x (lambda y (lambda z (lambda w (call + (var y) (var z) (string "(") (var x) (string ",") (var w) (string ")")))))))

(rule $SENTENCE ($ENT $TOHAVE ($DET optional) value $REL $ENT) (lambda x (lambda y (lambda z (lambda w (call + (var y) (var z) (string "(") (var x) (string ",") (var w) (string ")")))))))

(rule $SENTENCE ($ENT $TOHAVE ($DET optional) value $REL $NUM) (lambda x (lambda y (lambda z (lambda w (call + (var y) (var z) (string "(") (var x) (string ",") (var w) (string ")")))))))


(rule $NUM ($TOKEN , $TOKEN) (lambda x (lambda y (call + (var x) (var y)))))
(rule $NUM ($TOKEN , $TOKEN , $TOKEN) (lambda x (lambda y (lambda z (call + (var x) (var y) (var z))))))

# Optional MODIFIER

(rule $ENT ($ENT $OPTMOD) (lambda x (lambda y (var x))))
(rule $SENTENCE ($SENTENCE $OPTMOD) (lambda x (lambda y (var x))))
(rule $SENTENCE ($OPTMOD $SENTENCE) (lambda x (lambda y (var y))))

(rule $OPTMOD ($PP) (lambda x (var x)))
(rule $OPTMOD (provided) (ConstantFn (string "")))
(rule $OPTMOD (if an amount is entered) (ConstantFn (string "")))
(rule $OPTMOD (to $ENT) (ConstantFn (string "")))
(rule $PP ($PREP $NPP) (ConstantFn (string "")))
(rule $PP (in $ENT) (ConstantFn (string "")))
(rule $PP (in $ENT present $PP) (ConstantFn (string "")))
(rule $PP (in $ENT attached $PP) (ConstantFn (string "")))
(rule $PP ($PP ,) (ConstantFn (string "")))
(rule $PREP (in) (ConstantFn (string "")))
(rule $PREP (on) (ConstantFn (string "")))
(rule $NPP ($FIELD) (ConstantFn (string "")))
(rule $NPP (($DET optional) return) (ConstantFn (string "")))
(rule $NPP (($DET optional) return header) (ConstantFn (string "")))
(rule $NPP (($DET optional) ($TOKEN optional) ($TOKEN optional) $TOKEN) (ConstantFn (string "")))

(rule $ROOT ($ENT) (lambda x (var x)))
(rule $ROOT ($TOHAVE) (lambda x (var x)))
(rule $ROOT ($SENTENCE) (lambda x (var x)))
(rule $ROOT ($FIELDNAME) (lambda x (var x)))

# noun+VP coordination (and, or)
# sum of, +, -, following+these, each, at least one,
# unquoted name Primary SSN, Spouse SSN
# anaphoric "both"
# has no entry
# form number coordination
#unique
# parse only first sentence
# valid range
# years old
# have 'a' value greater than zero
# ITIN -- is $det $token == token
#  If Form 1040, Line 2 checkbox "Married filing jointly" is not checked ( element 'IndividualReturnFilingStatusCd' does not have the value 2 ) and 'PrimaryDeathDt' has a value, then Personal Representative Indicator checkbox 'PersonalRepresentativeInd' must be checked

# If Form 1040, Line 66a 'EICEligibilityLiteralCd' has the value 'NO', then Line 66a 'EarnedIncomeCreditAmt' not be present
